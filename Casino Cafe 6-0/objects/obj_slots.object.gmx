<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_symbols_128</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>size = sprite_height; //The size of the symbols, determins the spacing between each symbol (sprites must be square).
x1 = 384; //The left most x value, to start drawing the slot machine.
y1 = 128; //The y value of the top of the visible area (once a item gets to the bottom it will be above this value by your sprite height).
step = 32; //The distance the reels will move every step (has to be a whole number, and divide into the sprite height evenly).
symbols = 10; //The number of symbols for this perticular slot machine (shouldn't be more than sub images in your sprtite).
payback = 92; //The percent of money the player will recive back (will be within 1% of this value after 1m spins, anything can happen in a few pulls)

lines = 1; //Current amount of lines being played.
maxlines = 9; //The maxium amount of lines this machine will allow.

minbet = 50; //The minimum ammount to bet per line.
bet = minbet; //Current bet.
maxbet = 250 //The maximum ammount to bet per line (must be divisible by the minbet evenly).

global.gold = global.money; //Current amount of gold.

showlines = 1; //Varible that states whether or not to show the lines.
clicked = 0; //Varible that gets set to ture when the spin button is pressed.

stop1 = 0; //A timer that states when reel1 should stop at its next point (point is when it is lined up on the screen).
stop2 = 0; //A timer that states when reel2 should stop at its next point
stop3 = 0; //A timer that states when reel3 should stop at its next point
stop4 = 0; //A timer that states when reel4 should stop at its next point
stop5 = 0; //A timer that states when reel5 should stop at its next point
wrot = 0; //A varible that will incrase by 5 every step used to determine the rotation of the winning sprite
haswon = true; //A varible that states whether we are spinning or not (doesn't mean we auctualy won something)

randomize(); //Randomizes the rng.
scr_get_payout(); //Gets the payout for each win.

for(i = 0; i &lt;= 3; i++;) { //Creates the y varibles for each reel each reel has 4 y varibles.
    reel1y[i] = y1 + i * size;
    reel2y[i] = y1 + i * size;
    reel3y[i] = y1 + i * size;
    reel4y[i] = y1 + i * size;
    reel5y[i] = y1 + i * size;
}

for(i = 0; i &lt;= 3; i++;) { //Picking random values that represent image index for each of the 4 spots on every reel (uses real casino tactics, each symbol has an equal chance of being shown in the begining, so players see more "rare" symbols).
    reel1[i] = round(random(symbols - 1));
    reel2[i] = round(random(symbols - 1));
    reel3[i] = round(random(symbols - 1));
    reel4[i] = round(random(symbols - 1));
    reel5[i] = round(random(symbols - 1));
}

for (n = 0; n &lt;= 4; n++) { //A value of 1 or 0 stating whether a spot on the reel was involved in a win (so we can display the winning animation).
    row1w[n] = 0;
    row2w[n] = 0;
    row3w[n] = 0;
    row4w[n] = 0;
    row5w[n] = 0;
}

for (n = 0; n &lt;= 8; n++) { //A value of 1 or 0 stating whether a line has won or not.
    linew[n] = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for(i = 0; i &lt;= 3; i++;) { //Checkes each reel's y values, if they are below the screen they jump to the top and get a new symbol.
    if (reel1y[i] &gt;= y1 + size * 3) { //Checks the y values of each symbol.
        reel1y[i] = y1 - size; //Sets the new y value for any spot below the screen.
        reel1[i] = scr_get_item(); //gets a new symbol to be displayed for the spot.
    }
    if (reel2y[i] &gt;= y1 + size * 3) { //repeates above code for each reel
        reel2y[i] = y1 - size;
        reel2[i] = scr_get_item();
    }
    if (reel3y[i] &gt;= y1 + size * 3) {
        reel3y[i] = y1 - size;
        reel3[i] = scr_get_item();
    }
    if (reel4y[i] &gt;= y1 + size * 3) {
        reel4y[i] = y1 - size;
        reel4[i] = scr_get_item();
    }
    if (reel5y[i] &gt;= y1 + size * 3) {
        reel5y[i] = y1 - size;
        reel5[i] = scr_get_item();
    }
}

if (reel1y[0] mod size != 0 or stop1 != 0) { //Check whether or not we should be spinning. - If our y value isn't lined up or our varible to stop says contunue.
    for(i = 0; i &lt;= 3; i++;) { //Repeates for each y value of the reel.
        reel1y[i] += step; //Changes the y value by our step varible.
    }
    if (stop1 == 1) { //When the timer is 1 step away from stoping.
        audio_play_sound(snd_slot_stop, 1, 0); //Plays our sound for stopping.
    }
} else { //When we have stopped.
    for(i = 0; i &lt;= 3; i++;) { //Repeates for each y value of the reel.
        if (reel1y[i] = y1) { //Since our 4 y values of the reel are aren't in order, as they loop, we need to figure out which one is stopped at the top row.
            reel1w[0] = reel1[i]; //Saves the symbol that is located at the top row.
            i = 4; //Set i to 4 to stop the loop (loop repeats while i &lt;= 3).
        }
    }
    for(i = 0; i &lt;= 3; i++;) { //Same as above but for row 2.
        if (reel1y[i] = y1 + size) {
            reel1w[1] = reel1[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) { //Same as above but for row 3.
        if (reel1y[i] = y1 + size * 2) {
            reel1w[2] = reel1[i];
            i = 4;
        }
    }
}

if (reel2y[0] mod size != 0 or stop2 != 0) { //Same as above but for reel2.
    for(i = 0; i &lt;= 3; i++;) {
        reel2y[i] += step;
    }
    if (stop2 == 1) {
        audio_play_sound(snd_slot_stop, 1, 0);
    }
} else {
    for(i = 0; i &lt;= 3; i++;) {
        if (reel2y[i] = y1) {
            reel2w[0] = reel2[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) {
        if (reel2y[i] = y1 + size) {
            reel2w[1] = reel2[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) {
        if (reel2y[i] = y1 + size * 2) {
            reel2w[2] = reel2[i];
            i = 4;
        }
    }
}

if (reel3y[0] mod size != 0 or stop3 != 0) { //Same as above but for reel3.
    for(i = 0; i &lt;= 3; i++;) {
        reel3y[i] += step;
    }
    if (stop3 == 1) {
        audio_play_sound(snd_slot_stop, 1, 0);
    }
} else {
    for(i = 0; i &lt;= 3; i++;) {
        if (reel3y[i] = y1) {
            reel3w[0] = reel3[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) {
        if (reel3y[i] = y1 + size) {
            reel3w[1] = reel3[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) {
        if (reel3y[i] = y1 + size * 2) {
            reel3w[2] = reel3[i];
            i = 4;
        }
    }
}

if (reel4y[0] mod size != 0 or stop4 != 0) { //Same as above but for reel4.
    for(i = 0; i &lt;= 3; i++;) {
        reel4y[i] += step;
    }
    if (stop4 == 1) {
        audio_play_sound(snd_slot_stop, 1, 0);
    }
} else {
    for(i = 0; i &lt;= 3; i++;) {
        if (reel4y[i] = y1) {
            reel4w[0] = reel4[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) {
        if (reel4y[i] = y1 + size) {
            reel4w[1] = reel4[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) {
        if (reel4y[i] = y1 + size * 2) {
            reel4w[2] = reel4[i];
            i = 4;
        }
    }
}

if (reel5y[0] mod size != 0 or stop5 != 0) { //Same as above but for reel5.
    for(i = 0; i &lt;= 3; i++;) {
        reel5y[i] += step;
    }
    if (stop5 == 1) {
        audio_play_sound(snd_slot_stop, 1, 0);
        audio_stop_sound(snd_slots);
    }
} else {
    for(i = 0; i &lt;= 3; i++;) {
        if (reel5y[i] = y1) {
            reel5w[0] = reel5[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) {
        if (reel5y[i] = y1 + size) {
            reel5w[1] = reel5[i];
            i = 4;
        }
    }
    for(i = 0; i &lt;= 3; i++;) {
        if (reel5y[i] = y1 + size * 2) {
            reel5w[2] = reel5[i];
            i = 4;
        }
    }
    if (haswon = false) { //Checks whether the varible that states we have stopped running has been set to stopeed.
        scr_check_winnings(); //Runs the script that checks each line to see if we have won.
        haswon = true; //Sets the varible that states whether we stopped to stopped.
    }
}

if (stop1 &gt; 0) {stop1--;} //Checks if the timers for when the reels should stop is bigger than 0 if so it minuses 1.
if (stop2 &gt; 0) {stop2--;}
if (stop3 &gt; 0) {stop3--;}
if (stop4 &gt; 0) {stop4--;}
if (stop5 &gt; 0) {stop5--;}

wrot += 5; //Changes our winning sprite rotation by plus 5.

if (clicked == 1) { //When our varible that states if the spin button has been pressed it true.
    if (haswon == 1 &amp;&amp; global.gold &gt;= bet * lines) { //Checks if we are spinning, and if we have enough gold.
        scr_get_payout(); //Gets the payouts for each symbol.
        for (n = 0; n &lt;= 4; n++) { //Repeats for the number of reels and sets the saved reel symbols to nothing.
            row1w[n] = 0;
            row2w[n] = 0;
            row3w[n] = 0;
            row4w[n] = 0;
            row5w[n] = 0;
        }
        for (n = 0; n &lt;= 8; n++) { //Repeats for the number of lines.
            linew[n] = 0; //Sets if they have won to false.
        }
        stop1 = 128 + 16; //The number of steps before reel 1 stops spinning.
        stop2 = 128 + 32; //The number of steps before reel 2 stops spinning.
        stop3 = 128 + 48; //The number of steps before reel 3 stops spinning.
        stop4 = 128 + 64; //The number of steps before reel 4 stops spinning.
        stop5 = 128 + 80; //The number of steps before reel 5 stops spinning.
        haswon = false; //Sets the varible that states if we stopped spinning to false.
        audio_play_sound(snd_slots, 2, 1); //Starts our spinning sound.
        audio_play_sound(snd_slot_start, 1, 0); //plays the pulling of the lever sound.
        global.gold -= bet * lines; //Minuses the amount of gold by the cost to play.
    }
    clicked = 0; //Changes the varbile that states if the spin button was pressed to false;
    if (instance_exists(obj_counter)) { //Checks if the counter exists.
        with (obj_counter) {
            instance_destroy(); //Destorys it.
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(spr_slots_bg, 0, 704 - 320, 128, 1, 1, 0, image_blend, 1); //Optional draws the background behind the symbols.
draw_sprite_ext(spr_slots_bg, 0, 704 + 320, 128, -1, 1, 0, image_blend, 1); //The background is cut in half and mirrored.

for (n = 0; n &lt;= 4; n++) {
    if (row1w[n] = 1) { //Checks if the spot on row1 was involved in a win
        draw_sprite_ext(spr_winner, 0, x1 + size / 2 + n * size, y1 + size / 2, 1.2, 1.2, 0, image_blend, 1); // Draws the winning sprite behind the item.
        draw_sprite_ext(spr_winner, 1, x1 + size / 2 + n * size, y1 + size / 2, 1.2, 1.2, wrot, image_blend, 1); // Draws the winning sprite behind the item with the rotation.
    }
    if (row2w[n] = 1) {
        draw_sprite_ext(spr_winner, 0, x1 + size / 2 + n * size, y1 + size / 2 + size, 1.2, 1.2, 0, image_blend, 1); //Same as above.
        draw_sprite_ext(spr_winner, 1, x1 + size / 2 + n * size, y1 + size / 2 + size, 1.2, 1.2, wrot, image_blend, 1); //Same as above.
    }
    if (row3w[n] = 1) {
        draw_sprite_ext(spr_winner, 0, x1 + size / 2 + n * size, y1 + size / 2 + size * 2, 1.2, 1.2, 0, image_blend, 1); //Same as above.
        draw_sprite_ext(spr_winner, 1, x1 + size / 2 + n * size, y1 + size / 2 + size * 2, 1.2, 1.2, wrot, image_blend, 1); //Same as above.
    }
}

for(i = 0; i &lt;= 3; i++;) { //Repeates for the 4 different y values on each reel.
    draw_sprite_ext(sprite_index, reel1[i], x1, reel1y[i], 1, 1, 0, image_blend, 1); //Draws the sprite of each symbol at the y values.
    draw_sprite_ext(sprite_index, reel2[i], x1 + size, reel2y[i], 1, 1, 0, image_blend, 1);
    draw_sprite_ext(sprite_index, reel3[i], x1 + size * 2, reel3y[i], 1, 1, 0, image_blend, 1);
    draw_sprite_ext(sprite_index, reel4[i], x1 + size * 3, reel4y[i], 1, 1, 0, image_blend, 1);
    draw_sprite_ext(sprite_index, reel5[i], x1 + size * 4, reel5y[i], 1, 1, 0, image_blend, 1);
}

draw_rectangle(x1, y1 - size, x1 + size * 5, y1 - 1, 0); //Draws rectangle the covers symbols above the screen.
draw_rectangle(x1, y1 + size * 3, x1 + size * 5, y1 + size * 4, 0); //Draws rectangle the covers symbols below the screen.
draw_sprite_ext(spr_slots_overlay, 0, 0, 128, 1, 1, 0, image_blend, 1); //Optional draws the background.
draw_sprite_ext(spr_slots_overlay, 0, 1408, 128, -1, 1, 0, image_blend, 1); //The background is cut in half and mirrored.

draw_set_halign(fa_center); //Setting text options
draw_set_valign(fa_center);
draw_set_font(font_slots);
if (haswon == 1) { //If we have stopped spinning.
    draw_text_outline("Press space to start spinning!", 704, 512 + 64, 2);
} else {
    draw_text_outline("Spinning, good luck!", 704, 512 + 64, 2);
}
draw_set_halign(fa_left);

//*******************************************************************************************************************************************************************//
//                                                                                                                                                                   //
//Drawing winning lines | I'm not going to comment this section, all its doing is checking if a line has won and draws lines that follow the path of the winning line//
//                                                                                                                                                                   //
//*******************************************************************************************************************************************************************//

for(i = 1; i &gt;= 0; i--;) {
    if (linew[i] == 1 or (showlines == 1 &amp;&amp; lines &gt;= 2 - i)) {
        draw_line_width_colour(x1, y1 + size / 2 + size * i, x1 + size * 5, y1 + size / 2 + size * i, max(size / 16, 1), make_colour_rgb(231, 78, 18), make_colour_rgb(231, 78, 18));
    }
}
if (linew[2] == 1 or (showlines == 1 &amp;&amp; lines &gt;= 3)) {
        draw_line_width_colour(x1, y1 + size / 2 + size * 2, x1 + size * 5, y1 + size / 2 + size * 2, max(size / 16, 1), make_colour_rgb(231, 78, 18), make_colour_rgb(231, 78, 18));
    }
if (linew[3] == 1 or (showlines == 1 &amp;&amp; lines &gt;= 4)) {
    draw_line_width_colour(x1, y1 + size / 4, x1 + size / 2, y1 + size / 4, max(size / 16, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154));
    draw_line_width_colour(x1 + size / 2, y1 + size / 4, x1 + size * 2 + size / 2, y1 + size * 2 + size / 4, max(size / 16, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154));
    draw_line_width_colour(x1 + size * 2 + size / 2, y1 + size * 2 + size / 4, x1 + size * 4 + size / 2, y1 + size / 4, max(size / 16, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154));
    draw_line_width_colour(x1 + size * 4 + size / 2, y1 + size / 4, x1 + size * 5, y1 + size / 4, max(size / 16, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154));
    draw_circle_colour(x1 + size / 2, y1 + size / 4, max(size / 12, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154), 0);
    draw_circle_colour(x1 + size * 4 + size / 2, y1 + size / 4, max(size / 12, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154), 0);
    draw_circle_colour(x1 + size * 2 + size / 2, y1 + size * 2 + size / 4, max(size / 12, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154), 0);
}
if (linew[4] == 1 or (showlines == 1 &amp;&amp; lines &gt;= 5)) {
    draw_line_width_colour(x1, y1 + size / 4 + size / 2 + size * 2, x1 + size / 2, y1 + size / 4 + size / 2 + size * 2, max(size / 16, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154));
    draw_line_width_colour(x1 + size / 2, y1 + size / 4 + size / 2 + size * 2, x1 + size * 2 + size / 2, y1 + size / 4 + size / 2, max(size / 16, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154));
    draw_line_width_colour(x1 + size * 2 + size / 2, y1 + size / 4 + size / 2, x1 + size * 4 + size / 2, y1 + size / 4 + size / 2 + size * 2, max(size / 16, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154));
    draw_line_width_colour(x1 + size * 4 + size / 2, y1 + size / 4 + size / 2 + size * 2, x1 + size * 5, y1 + size / 4 + size / 2 + size * 2, max(size / 16, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154));
    draw_circle_colour(x1 + size / 2, y1 + size * 2 + size / 4 + size / 2, max(size / 12, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154), 0);
    draw_circle_colour(x1 + size * 4 + size / 2, y1 + size * 2 + size / 4 + size / 2, max(size / 12, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154), 0);
    draw_circle_colour(x1 + size * 2 + size / 2, y1 + size / 4 + size / 2, max(size / 12, 1), make_colour_rgb(226, 18, 154), make_colour_rgb(226, 18, 154), 0);
}
if (linew[5] == 1 or (showlines == 1 &amp;&amp; lines &gt;= 6)) {
    draw_line_width_colour(x1, y1 + size / 4 + size / 2, x1 + size / 2 + size, y1 + size / 4 + size / 2, max(size / 16, 1), c_blue, c_blue);
    draw_line_width_colour(x1 + size / 2 + size, y1 + size / 4 + size / 2, x1 + size / 2 + size * 3, y1 + size / 4 + size / 2 + size * 2, max(size / 16, 1), c_blue, c_blue);
    draw_line_width_colour(x1 + size / 2 + size * 3, y1 + size / 4 + size / 2 + size * 2, x1 + size * 5, y1 + size / 4 + size / 2 + size * 2, max(size / 16, 1), c_blue, c_blue);
    draw_circle_colour(x1 + size / 2 + size, y1 + size / 4 + size / 2, max(size / 12, 1), c_blue, c_blue, 0);
    draw_circle_colour(x1 + size / 2 + size * 3, y1 + size / 4 + size / 2 + size * 2, max(size / 12, 1), c_blue, c_blue, 0);
}
if (linew[6] == 1 or (showlines == 1 &amp;&amp; lines &gt;= 7)) {
    draw_line_width_colour(x1, y1 + size / 4 + size * 2, x1 + size / 2 + size, y1 + size / 4 + size * 2, max(size / 16, 1), c_blue, c_blue);
    draw_line_width_colour(x1 + size / 2 + size, y1 + size / 4 + size * 2, x1 + size / 2 + size * 3, y1 + size / 4, max(size / 16, 1), c_blue, c_blue);
    draw_line_width_colour(x1 + size / 2 + size * 3, y1 + size / 4, x1 + size * 5, y1 + size / 4, max(size / 16, 1), c_blue, c_blue);
    draw_circle_colour(x1 + size / 2 + size, y1 + size / 4 + size * 2, max(size / 12, 1), c_blue, c_blue, 0);
    draw_circle_colour(x1 + size / 2 + size * 3, y1 + size / 4, max(size / 12, 1), c_blue, c_blue, 0);
}
if (linew[7] == 1 or (showlines == 1 &amp;&amp; lines &gt;= 8)) {
    draw_line_width_colour(x1, y1 + size + size / 4, x1 + size / 2, y1 + size + size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_line_width_colour(x1 + size / 2, y1 + size + size / 4, x1 + size + size / 2, y1 + size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_line_width_colour(x1 + size + size / 2, y1 + size / 4, x1 + size * 3 + size / 2, y1 + size * 2 + size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_line_width_colour(x1 + size * 3 + size / 2, y1 + size * 2 + size / 4, x1 + size * 4 + size / 2, y1 + size + size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_line_width_colour(x1 + size * 4 + size / 2, y1 + size + size / 4, x1 + size * 5, y1 + size + size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_circle_colour(x1 + size / 2, y1 + size + size / 4, max(size / 12, 1), c_lime, c_lime, 0);
    draw_circle_colour(x1 + size + size / 2, y1 + size / 4, max(size / 12, 1), c_lime, c_lime, 0);
    draw_circle_colour(x1 + size * 3 + size / 2, y1 + size * 2 + size / 4, max(size / 12, 1), c_lime, c_lime, 0);
    draw_circle_colour(x1 + size * 4 + size / 2, y1 + size + size / 4, max(size / 12, 1), c_lime, c_lime, 0);
}
if (linew[8] == 1 or (showlines == 1 &amp;&amp; lines &gt;= 9)) {
    draw_line_width_colour(x1, y1 + size * 2 - size / 4, x1 + size / 2, y1 + size * 2 - size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_line_width_colour(x1 + size / 2, y1 + size * 2 - size / 4, x1 + size * 2 - size / 2, y1 + size * 3 - size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_line_width_colour(x1 + size * 2 - size / 2, y1 + size * 3 - size / 4, x1 + size * 4 - size / 2, y1 + size - size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_line_width_colour(x1 + size * 4 - size / 2, y1 + size - size / 4, x1 + size * 5 - size / 2, y1 + size * 2 - size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_line_width_colour(x1 + size * 5 - size / 2, y1 + size * 2 - size / 4, x1 + size * 5, y1 + size * 2 - size / 4, max(size / 16, 1), c_lime, c_lime);
    draw_circle_colour(x1 + size / 2, y1 + size * 2 - size / 4, max(size / 12, 1), c_lime, c_lime, 0);
    draw_circle_colour(x1 + size * 2 - size / 2, y1 + size * 3 - size / 4, max(size / 12, 1), c_lime, c_lime, 0);
    draw_circle_colour(x1 + size * 4 - size / 2, y1 + size - size / 4, max(size / 12, 1), c_lime, c_lime, 0);
    draw_circle_colour(x1 + size * 5 - size / 2, y1 + size * 2 - size / 4, max(size / 12, 1), c_lime, c_lime, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>64,64</point>
  </PhysicsShapePoints>
</object>
